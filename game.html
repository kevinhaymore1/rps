<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPS Battle Simulator</title>
    <style>
        /* Base Styling */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #E0E0FF; /* Light text for dark background */
            background: #111827; /* Dark base color */
            overflow: hidden; /* Hide scroll bars */
        }

        /* Northern Lights Animated Background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            /* Complex, slow-moving radial gradient for Aurora effect */
            background: radial-gradient(
                circle at 20% 80%, rgba(5, 46, 75, 0.4) 10%, transparent 50%
            ), radial-gradient(
                circle at 80% 20%, rgba(7, 72, 45, 0.4) 10%, transparent 50%
            ), radial-gradient(
                circle at 50% 50%, rgba(30, 0, 40, 0.4) 10%, transparent 50%
            ), linear-gradient(
                135deg, #0f0a1c, #07071e
            );
            background-size: 400% 400%;
            animation: aurora-move 45s ease infinite alternate;
        }

        @keyframes aurora-move {
            0% {
                background-position: 0% 0%;
            }
            100% {
                background-position: 100% 100%;
            }
        }

        .container {
            background-color: rgba(20, 20, 40, 0.9); /* Semi-transparent dark container */
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 95vw;
            width: 1000px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px;
        }

        /* --- Collapsible Settings Styles --- */
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-bottom: -15px; /* Pull it slightly into the margin */
        }

        .settings-header:hover {
            background-color: rgba(0, 0, 0, 0.5);
        }

        .settings-header h2 {
            margin: 0;
            font-size: 1.2rem;
            color: #E0E0FF;
        }

        #toggleSettingsButton {
            background: none;
            border: 1px solid #60A5FA;
            color: #60A5FA;
            padding: 5px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #toggleSettingsButton:hover {
            background-color: rgba(96, 165, 250, 0.1);
        }

        #settings-content {
            max-height: 500px; /* Large enough to hold content */
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out, opacity 0.3s;
            opacity: 1;
            padding-top: 20px;
        }

        #settings-content.collapsed {
            max-height: 0;
            padding-top: 0;
            opacity: 0;
        }
        /* --- END Collapsible Settings Styles --- */


        .controls-panel {
            display: grid;
            grid-template-columns: repeat(2, 1fr) 1.5fr;
            gap: 15px;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 12px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-size: 0.9rem;
            margin-bottom: 4px;
            font-weight: 600;
            color: #9EC0FF;
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            height: 8px;
            background: #444;
            border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #9EC0FF;
            cursor: pointer;
        }

        .input-pair {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .input-pair input[type="number"] {
            width: 60px;
            padding: 5px;
            border-radius: 6px;
            border: 1px solid #444;
            background-color: #222;
            color: #fff;
            text-align: center;
        }

        #startStopButton {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            grid-column: 3;
            background: linear-gradient(145deg, #10b981, #059669); /* Tailwind-inspired green */
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        }

        #startStopButton:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.6);
        }

        #canvas {
            border-radius: 12px;
            background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent canvas background */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
            touch-action: none; /* Disable default touch actions for better responsiveness */
        }

        .status-bar {
            display: flex;
            justify-content: space-around;
            padding: 10px 0;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.3);
        }

        .status-item {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .status-item span {
            display: block;
            font-size: 0.8rem;
            font-weight: normal;
            margin-top: 4px;
            color: #C0C0C0;
        }

        #rockCount { color: #F87171; } /* Reddish */
        #paperCount { color: #60A5FA; } /* Bluish */
        #scissorsCount { color: #FBBF24; } /* Yellowish */

        /* Modal for Results */
        #resultsModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            border-radius: 16px;
            z-index: 10;
        }

        #resultsModal h2 {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: pulse 1.5s infinite alternate;
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            100% { transform: scale(1.05); opacity: 1; }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                margin: 10px;
            }
            .controls-panel {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            #startStopButton {
                grid-column: 1 / span 2;
            }
            .status-item {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1 style="text-align: center; font-size: 2rem; color: #E0E0FF;">RPS 2D Battle Simulator</h1>

        <!-- Settings Card with Collapsible Header -->
        <div class="settings-card">
            <div id="settings-header" class="settings-header">
                <h2>Simulation Settings</h2>
                <button id="toggleSettingsButton">Hide</button>
            </div>
            
            <!-- Collapsible Content -->
            <div id="settings-content">
                <div class="controls-panel">
                    <!-- Rock Count -->
                    <div class="control-group">
                        <label for="rock-count">Rock Count (3-10):</label>
                        <div class="input-pair">
                            <input type="range" id="rock-range" min="3" max="10" value="7">
                            <input type="number" id="rock-count" min="3" max="10" value="7">
                        </div>
                    </div>

                    <!-- Paper Count -->
                    <div class="control-group">
                        <label for="paper-count">Paper Count (3-10):</label>
                        <div class="input-pair">
                            <input type="range" id="paper-range" min="3" max="10" value="7">
                            <input type="number" id="paper-count" min="3" max="10" value="7">
                        </div>
                    </div>

                    <!-- Speed -->
                    <div class="control-group">
                        <label for="speed-range">Speed (1-5):</label>
                        <div class="input-pair">
                            <input type="range" id="speed-range" min="1" max="5" step="0.5" value="1.5">
                            <input type="number" id="speed-display" min="1" max="5" step="0.5" value="1.5" disabled>
                        </div>
                    </div>

                    <!-- Scissors Count -->
                    <div class="control-group">
                        <label for="scissors-count">Scissors Count (3-10):</label>
                        <div class="input-pair">
                            <input type="range" id="scissors-range" min="3" max="10" value="7">
                            <input type="number" id="scissors-count" min="3" max="10" value="7">
                        </div>
                    </div>

                    <!-- Size -->
                    <div class="control-group">
                        <label for="size-range">Icon Size (15-30px):</label>
                        <div class="input-pair">
                            <input type="range" id="size-range" min="15" max="30" value="20">
                            <input type="number" id="size-display" min="15" max="30" value="20" disabled>
                        </div>
                    </div>

                    <button id="startStopButton">Start Battle</button>
                </div>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item" style="color: #F87171;">
                Rock: <span id="rockCount">0</span>
            </div>
            <div class="status-item" style="color: #60A5FA;">
                Paper: <span id="paperCount">0</span>
            </div>
            <div class="status-item" style="color: #FBBF24;">
                Scissors: <span id="scissorsCount">0</span>
            </div>
        </div>

        <!-- Simulation Canvas -->
        <canvas id="canvas" width="960" height="540"></canvas>
    </div>

    <!-- Results Modal (Hidden until end of simulation) -->
    <div id="resultsModal">
        <h2 id="winnerText"></h2>
        <p style="font-size: 1.5rem; color: #fff;">The battle is won!</p>

        <!-- New LLM Analysis Placeholder -->
        <div id="analysisContainer" style="margin-top: 20px; width: 80%; max-width: 500px; padding: 15px; background: rgba(255, 255, 255, 0.1); border-radius: 8px; text-align: left; display: none;">
             <p id="analysisText" style="font-size: 1rem; color: #fff; line-height: 1.4;"></p>
             <p id="analysisLoading" style="color: #9EC0FF;">Analyzing...</p>
        </div>

        <!-- New LLM Buttons and Audio -->
        <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-top: 20px;">
            <button id="analyzeButton" style="
                background: linear-gradient(145deg, #FFD700, #C5B358); color: #111827; padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;
                box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4); transition: transform 0.2s;
            ">âœ¨ Analyze Battle</button>
            <button id="speakerButton" style="
                background: linear-gradient(145deg, #1D976C, #93F9B9); color: white; padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;
                box-shadow: 0 4px 15px rgba(29, 151, 108, 0.4); transition: transform 0.2s;
            ">ðŸ”Š Hear Winner</button>
        </div>

        <button onclick="resetSimulation()" style="
            background: #9333ea; color: white; padding: 10px 20px; border: none; border-radius: 8px; margin-top: 20px; cursor: pointer; font-weight: bold;
            box-shadow: 0 4px 15px rgba(147, 51, 234, 0.4); transition: transform 0.2s;
        ">Run New Simulation</button>
    </div>

    <audio id="ttsAudio" style="display: none;"></audio>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const resultsModal = document.getElementById('resultsModal');
        const winnerText = document.getElementById('winnerText');
        const rockCountDisplay = document.getElementById('rockCount');
        const paperCountDisplay = document.getElementById('paperCount');
        const scissorsCountDisplay = document.getElementById('scissorsCount');
        const startStopButton = document.getElementById('startStopButton');
        const analyzeButton = document.getElementById('analyzeButton');
        const speakerButton = document.getElementById('speakerButton');
        const analysisContainer = document.getElementById('analysisContainer');
        const analysisText = document.getElementById('analysisText');
        const analysisLoading = document.getElementById('analysisLoading');
        const ttsAudio = document.getElementById('ttsAudio');

        // Control Inputs
        const rockRange = document.getElementById('rock-range');
        const rockNum = document.getElementById('rock-count');
        const paperRange = document.getElementById('paper-range');
        const paperNum = document.getElementById('paper-count');
        const scissorsRange = document.getElementById('scissors-range');
        const scissorsNum = document.getElementById('scissors-count');
        const speedRange = document.getElementById('speed-range');
        const speedDisplay = document.getElementById('speed-display');
        const sizeRange = document.getElementById('size-range');
        const sizeDisplay = document.getElementById('size-display');
        
        // Collapsible elements
        const settingsHeader = document.getElementById('settings-header');
        const settingsContent = document.getElementById('settings-content');
        const toggleSettingsButton = document.getElementById('toggleSettingsButton');

        let animationFrameId = null;
        let isRunning = false;
        let icons = [];
        let initialCounts = {}; // Store initial setup for analysis
        let finalCounts = {}; // Store final counts for analysis
        let finalWinnerType = "No one";

        // Gemini API configuration
        const apiKey = "";
        const LLM_MODEL = "gemini-2.5-flash-preview-09-2025";
        const TTS_MODEL = "gemini-2.5-flash-preview-tts";

        // Constants for the game
        const ICON_COLORS = {
            'rock': '#F87171', // Reddish
            'paper': '#60A5FA', // Bluish
            'scissors': '#FBBF24' // Yellowish
        };

        // Battle Rules: A > B means A wins against B
        const BATTLE_RULES = {
            'rock': 'scissors',
            'scissors': 'paper',
            'paper': 'rock'
        };

        // --- TTS Helper Functions ---

        // Converts a base64 string to an ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Converts signed 16-bit PCM audio data to a WAV file Blob
        function pcmToWav(pcm16, sampleRate = 24000) {
            const numChannels = 1;
            const bytesPerSample = 2; // 16-bit
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcm16.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            // RIFF chunk
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');

            // FMT chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);          // Sub-chunk size
            view.setUint16(20, 1, true);           // Audio format (1=PCM)
            view.setUint16(22, numChannels, true); // Channels
            view.setUint32(24, sampleRate, true);  // Sample rate
            view.setUint32(28, byteRate, true);    // Byte rate
            view.setUint16(32, blockAlign, true);  // Block align
            view.setUint16(34, 16, true);          // Bits per sample (16)

            // DATA chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);    // Data size

            // Write PCM data
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(44 + i * 2, pcm16[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        // --- LLM API Call Functions ---

        async function generateBattleAnalysis(winner, initial, final) {
            analysisContainer.style.display = 'block';
            analysisText.textContent = '';
            analysisLoading.style.display = 'block';
            analyzeButton.disabled = true;

            const userQuery = `Analyze the outcome of a Rock-Paper-Scissors battle simulation. Initial forces were Rock: ${initial.rock}, Paper: ${initial.paper}, Scissors: ${initial.scissors}. The final winner was ${winner} with ${final[winner] || 0} remaining unit${final[winner] === 1 ? '' : 's'}. Provide a concise, dramatic, single-paragraph summary of the battle, focusing on the tactical reasons for the outcome. If the winner is 'No one', analyze why mutual destruction occurred.`;
            
            const systemPrompt = "You are a dramatic, medieval-style war commentator. Use epic, exciting, and slightly exaggerated language to describe the battle's ebb and flow in a single paragraph.";

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${LLM_MODEL}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            let attempts = 0;
            const maxAttempts = 5;
            let resultText = "Analysis failed. The war was too chaotic for words!";

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        resultText = result.candidates?.[0]?.content?.parts?.[0]?.text || resultText;
                        break;
                    } else if (response.status === 429) {
                        // Rate limit exceeded, implement exponential backoff
                        const delay = Math.pow(2, attempts) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        attempts++;
                    } else {
                        // Other non-retryable error
                        break;
                    }
                } catch (error) {
                    // Network error, retry
                    const delay = Math.pow(2, attempts) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    attempts++;
                }
            }

            analysisLoading.style.display = 'none';
            analysisText.textContent = resultText;
            analyzeButton.disabled = false;
        }

        async function speakWinner(textToSpeak) {
            speakerButton.disabled = true;
            speakerButton.textContent = 'ðŸ”Š Speaking...';

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: `Say in a dramatic, announcer voice: ${textToSpeak}` }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Kore" } // A firm, clear voice
                        }
                    }
                },
                model: TTS_MODEL
            };
            
            let attempts = 0;
            const maxAttempts = 5;
            let audioPlayed = false;

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        const part = result?.candidates?.[0]?.content?.parts?.[0];
                        const audioData = part?.inlineData?.data;

                        if (audioData) {
                            const sampleRate = 24000; // Default sample rate for this TTS model
                            const pcmData = base64ToArrayBuffer(audioData);
                            const pcm16 = new Int16Array(pcmData);
                            const wavBlob = pcmToWav(pcm16, sampleRate);
                            const audioUrl = URL.createObjectURL(wavBlob);

                            ttsAudio.src = audioUrl;
                            await ttsAudio.play();
                            audioPlayed = true;
                            break;
                        }
                    } else if (response.status === 429) {
                         // Rate limit exceeded, implement exponential backoff
                        const delay = Math.pow(2, attempts) * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                        attempts++;
                    } else {
                        break;
                    }
                } catch (error) {
                    const delay = Math.pow(2, attempts) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    attempts++;
                }
            }

            if (!audioPlayed) {
                console.error("Failed to generate or play TTS audio.");
            }

            speakerButton.textContent = 'ðŸ”Š Hear Winner';
            speakerButton.disabled = false;
        }


        // --- Icon Class ---
        class Icon {
            constructor(type, x, y, radius, speed) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = ICON_COLORS[type];
                this.defeated = false; // New flag to mark icons for removal

                // Initial velocity is randomized based on speed multiplier
                const angle = Math.random() * 2 * Math.PI;
                // SLOW DOWN: Reduced base velocity from 1 to 0.5 for better visibility
                const baseVel = 0.5 * speed; // Base velocity magnitude
                this.vx = Math.cos(angle) * baseVel;
                this.vy = Math.sin(angle) * baseVel;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();

                // Draw the initial letter for better identification
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `${this.radius}px Inter`;
                ctx.fillText(this.type[0].toUpperCase(), this.x, this.y);
            }

            update(speedMultiplier) {
                // Apply speed multiplier to movement
                this.x += this.vx * speedMultiplier;
                this.y += this.vy * speedMultiplier;

                // Wall Collision Detection & Response
                // Check right/left walls
                if (this.x + this.radius > canvas.width || this.x - this.radius < 0) {
                    this.vx *= -1; // Reverse X velocity
                    this.x = Math.max(this.radius, Math.min(canvas.width - this.radius, this.x)); // Adjust position
                }

                // Check top/bottom walls
                if (this.y + this.radius > canvas.height || this.y - this.radius < 0) {
                    this.vy *= -1; // Reverse Y velocity
                    this.y = Math.max(this.radius, Math.min(canvas.height - this.radius, this.y)); // Adjust position
                }
            }
        }

        // --- Core Functions ---

        function updateCounts() {
            const counts = icons.reduce((acc, icon) => {
                acc[icon.type] = (acc[icon.type] || 0) + 1;
                return acc;
            }, {});

            rockCountDisplay.textContent = counts['rock'] || 0;
            paperCountDisplay.textContent = counts['paper'] || 0;
            scissorsCountDisplay.textContent = counts['scissors'] || 0;

            // Check for end condition
            const activeTypes = Object.values(counts).filter(count => count > 0).length;

            if (activeTypes <= 1 && icons.length > 0) {
                finalWinnerType = Object.keys(counts).find(type => counts[type] > 0);
                finalCounts = counts;
                endSimulation(finalWinnerType);
                return true;
            }
            // Also end if all icons are eliminated in a high-attrition scenario
            if (icons.length === 0) {
                 finalWinnerType = "No one";
                 finalCounts = {rock: 0, paper: 0, scissors: 0};
                 endSimulation(finalWinnerType);
                 return true;
            }
            return false;
        }

        function spawnIcons() {
            icons = [];
            const rCount = parseInt(rockNum.value);
            const pCount = parseInt(paperNum.value);
            const sCount = parseInt(scissorsNum.value);
            const radius = parseInt(sizeRange.value);
            const speed = parseFloat(speedRange.value);

            initialCounts = { 'rock': rCount, 'paper': pCount, 'scissors': sCount };
            const allCounts = initialCounts;

            for (const type in allCounts) {
                for (let i = 0; i < allCounts[type]; i++) {
                    // Ensure icons spawn within canvas bounds and not immediately overlapping
                    let x, y, overlap;
                    do {
                        overlap = false;
                        // Random position within canvas, away from edges
                        x = radius + Math.random() * (canvas.width - 2 * radius);
                        y = radius + Math.random() * (canvas.height - 2 * radius);

                        // Check against existing icons for overlap
                        for (const existingIcon of icons) {
                            const dx = x - existingIcon.x;
                            const dy = y - existingIcon.y;
                            // Add a small buffer (e.g., 2px) to the minimum distance check
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < 2 * radius + 2) {
                                overlap = true;
                                break;
                            }
                        }
                    } while (overlap);

                    icons.push(new Icon(type, x, y, radius, speed));
                }
            }
        }

        function checkCollisions() {
            const sizeMultiplier = 1;
            const restitution = 1;

            for (let i = 0; i < icons.length; i++) {
                const iconA = icons[i];
                if (iconA.defeated) continue; // Skip if already defeated

                for (let j = i + 1; j < icons.length; j++) {
                    const iconB = icons[j];
                    if (iconB.defeated) continue; // Skip if already defeated

                    const dx = iconB.x - iconA.x;
                    const dy = iconB.y - iconA.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = iconA.radius + iconB.radius;

                    if (distance < minDist) {
                        // Collision Occurred

                        // 1. Separate the colliding icons to prevent sticking
                        const overlap = minDist - distance;
                        const nx = dx / distance; // Normal vector x
                        const ny = dy / distance; // Normal vector y
                        iconA.x -= nx * (overlap / 2);
                        iconA.y -= ny * (overlap / 2);
                        iconB.x += nx * (overlap / 2);
                        iconB.y += ny * (overlap / 2);

                        // 2. Battle or Bounce
                        if (iconA.type === iconB.type) {
                            // Same Type: Simple elastic bounce
                            const vdn = iconA.vx * nx + iconA.vy * ny - (iconB.vx * nx + iconB.vy * ny);

                            if (vdn > 0) continue;

                            // Mass is equal, so velocities along the normal swap (simplified)
                            iconA.vx -= vdn * nx * (1 + restitution);
                            iconA.vy -= vdn * ny * (1 + restitution);
                            iconB.vx += vdn * nx * (1 + restitution);
                            iconB.vy += vdn * ny * (1 + restitution);

                        } else {
                            // Different Type: Battle (Loser disappears)
                            let winner, loser;

                            if (BATTLE_RULES[iconA.type] === iconB.type) {
                                // A beats B
                                winner = iconA;
                                loser = iconB;
                            } else if (BATTLE_RULES[iconB.type] === iconA.type) {
                                // B beats A
                                winner = iconB;
                                loser = iconA;
                            } else {
                                console.error("Invalid battle state.");
                                continue;
                            }

                            // The losing icon is marked for removal!
                            loser.defeated = true; // <-- LOSER DISAPPEARS

                            // Apply a strong repulsion (bounce) to make the icons separate quickly
                            const speed = parseFloat(speedRange.value) * sizeMultiplier;
                            const repulsionForce = 1.5;
                            iconA.vx -= nx * speed * repulsionForce;
                            iconA.vy -= ny * speed * repulsionForce;
                            iconB.vx += nx * speed * repulsionForce;
                            iconB.vy += ny * speed * repulsionForce;

                            // NOTE: updateCounts() is now called in animate() after filtering.
                        }
                    }
                }
            }
        }


        function animate() {
            if (!isRunning) return;

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const speedMultiplier = 0.5; // Base update speed, separate from icon velocity

            // 1. Update icon positions
            for (const icon of icons) {
                icon.update(speedMultiplier);
            }

            // 2. Check and resolve collisions (marking losers as 'defeated')
            checkCollisions();

            // 3. Filter out defeated icons (they disappear)
            icons = icons.filter(icon => !icon.defeated);

            // 4. Update counts and check for end condition
            if (updateCounts()) {
                return;
            }

            // 5. Redraw remaining icons
            for (const icon of icons) {
                 icon.draw();
            }

            // Request next frame
            animationFrameId = requestAnimationFrame(animate);
        }

        function startSimulation() {
            if (isRunning) return;
            isRunning = true;
            resultsModal.style.display = 'none';
            analysisContainer.style.display = 'none';
            analysisText.textContent = '';
            
            spawnIcons();
            updateCounts(); // Initial count
            startStopButton.textContent = 'Running...';
            startStopButton.style.background = 'linear-gradient(145deg, #EF4444, #DC2626)'; // Red
            startStopButton.style.boxShadow = '0 4px 15px rgba(239, 68, 68, 0.4)';
            animate();
        }

        function endSimulation(winnerType) {
            cancelAnimationFrame(animationFrameId);
            isRunning = false;
            startStopButton.textContent = 'Start Battle';
            startStopButton.style.background = 'linear-gradient(145deg, #10b981, #059669)'; // Green
            startStopButton.style.boxShadow = '0 4px 15px rgba(16, 185, 129, 0.4)';

            const displayText = winnerType === "No one" ? "Mutual Destruction! (0 Remaining)" : `${winnerType.toUpperCase()} Wins!`;
            winnerText.textContent = displayText;
            winnerText.style.color = ICON_COLORS[winnerType] || '#fff';
            resultsModal.style.display = 'flex';

            // Set up LLM feature buttons
            analyzeButton.onclick = () => generateBattleAnalysis(winnerType, initialCounts, finalCounts);
            speakerButton.onclick = () => speakWinner(displayText);
        }

        function resetSimulation() {
            // Stop current animation if running
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            isRunning = false;
            icons = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            resultsModal.style.display = 'none';
            analysisContainer.style.display = 'none';
            analysisText.textContent = '';

            // Reset UI
            rockCountDisplay.textContent = rockNum.value;
            paperCountDisplay.textContent = paperNum.value;
            scissorsCountDisplay.textContent = scissorsNum.value;

            startStopButton.textContent = 'Start Battle';
            startStopButton.style.background = 'linear-gradient(145deg, #10b981, #059669)';
            startStopButton.style.boxShadow = '0 4px 15px rgba(16, 185, 129, 0.4)';

            // Prepare for next simulation (spawnIcons is called on Start)
        }
        
        // --- Collapsible Logic ---
        function toggleSettings() {
            const isCollapsed = settingsContent.classList.toggle('collapsed');
            toggleSettingsButton.textContent = isCollapsed ? 'Show' : 'Hide';
        }

        // --- Event Listeners and Setup ---

        settingsHeader.addEventListener('click', toggleSettings);


        // Link range and number inputs bidirectionally for count dials
        function setupCountSync(rangeId, numId) {
            const range = document.getElementById(rangeId);
            const num = document.getElementById(numId);
            range.addEventListener('input', () => { num.value = range.value; });
            num.addEventListener('change', () => {
                const val = Math.max(3, Math.min(10, parseInt(num.value) || 3));
                num.value = val;
                range.value = val;
            });
            // Initial setting for the status bar
            document.getElementById(numId.replace('-count', 'Count')).textContent = num.value;
        }

        setupCountSync('rock-range', 'rock-count');
        setupCountSync('paper-range', 'paper-count');
        setupCountSync('scissors-range', 'scissors-count');

        // Link range and display for speed/size
        speedRange.addEventListener('input', () => { speedDisplay.value = speedRange.value; });
        sizeRange.addEventListener('input', () => { sizeDisplay.value = sizeRange.value; });

        // Start/Stop button functionality
        startStopButton.addEventListener('click', () => {
            if (!isRunning) {
                startSimulation();
            } else {
                resetSimulation(); // Treat stopping as resetting for a fresh run
            }
        });

        // Responsive Canvas Resizing
        function resizeCanvas() {
            const containerWidth = document.querySelector('.container').clientWidth;
            // Set max width to container width, and keep a 16:9 ratio
            canvas.width = containerWidth - 48; // Padding correction
            canvas.height = (canvas.width / 16) * 9;
            if (isRunning) {
                // If running, stop and allow the user to restart with new dimensions
                cancelAnimationFrame(animationFrameId);
                isRunning = false;
                startStopButton.textContent = 'Start Battle (Restart Required)';
                startStopButton.style.background = 'linear-gradient(145deg, #9333ea, #6b21a8)'; // Purple
            }
            // Redraw initial state
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // Initial setup and resize handlers
        window.addEventListener('resize', resizeCanvas);
        window.onload = () => {
            resizeCanvas();
            resetSimulation(); // Call reset to set initial counts in status bar
            startSimulation(); // Start the battle immediately
        };

    </script>
</body>
</html>